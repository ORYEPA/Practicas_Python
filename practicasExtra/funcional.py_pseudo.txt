# Importing the libraries that are going to be used in the program.
IMPORT tkinter as tk
from tkinter IMPORT filedialog
IMPORT numpy as np #importe de libreria
from matplotlib IMPORT pyplot as plt #pa plotear
from PIL IMPORT Image
IMPORT cv2
from skimage IMPORT measure
from matplotlib.gridspec IMPORT GridSpec
"""
It takes an image, converts it to grayscale, then applies a threshold to it, then erodes it, then
dilates it, then applies a mask to it, then applies a threshold to it, then applies an adaptive
threshold to it, then plots the original image and the processed image

:param file: The name of the file to be processed
"""
DEFINE FUNCTION procesado_principal(file):
    img=Image.open(file).convert('L')
     # Getting the data from the image and then printing the maximum and minimum values of the image.
    SET # fig1, ax1 TO plt.subplots()
    SET # im TO ax1.imshow(img)
    SET # y TO np.array(range(0))
    pix_val=list(img.getdata())
    OUTPUT("Maximo= ", np.max(pix_val))
    OUTPUT("Minimo= ", np.min(pix_val))
    img=np.array(img)
    [n,m]=img.shape
    OUTPUT(n)
    OUTPUT(m)
     # Finding the number of islands in the image.
    bw_img=np.zeros(img.shape)
    umbral,img_bin=cv2.threshold(img,0,255,cv2.THRESH_BINARY+cv2.THRESH_OTSU)
    SET blobs_labels TO measure.label(img_bin, background=0)
    SET OUTPUT("Islas numero TO ",np.max(blobs_labels))
    SET kernel TO np.ones((3,3), np.uint8)
    OUTPUT(kernel)
     # Dilating the image and then finding the number of islands in the image.
    SET img_eroded TO cv2.erode(img_bin, kernel, iterations=2)
    SET umbral,img_bw TO cv2.threshold(img,0,255,cv2.THRESH_BINARY+cv2.THRESH_OTSU)
    SET OUTPUT("Umbral Otsu TO ", umbral)
    SET kernel TO np.ones((5,5),np.uint8)
    OUTPUT(kernel)
    SET img_dilate TO cv2.dilate(img_bw,kernel,iterations=5)
    SET blobs_labels TO measure.label(img_dilate,background=0)
    SET OUTPUT("Cantidad de islas TO ", np.max(blobs_labels))
    # Creating a mask that is going to be applied to the image.
    SET mask1 TO np.where(blobs_labels==1, 0,1)
    SET mask1 TO np.logical_not(mask1)
    SET img_mask TO np.copy(img)
    SET img_mask[mask1] TO 0
    SET mask2 TO np.where(blobs_labels==0, 1,1)
    mask2= np.logical_not(mask2)
    SET img_mask2 TO np.copy(img)
    SET img_mask2[mask2] TO 0
    SET mask3 TO np.where(blobs_labels==1,1,0)
    mask3= np.logical_not(mask3)
    SET img_mask3 TO np.copy(img)
    SET img_mask3[mask3] TO 0
    # Applying a threshold to the image.
    SET ret,th1 TO cv2.threshold(img_mask,110,255,cv2.THRESH_BINARY)
    SET ret2,th2 TO cv2.threshold(img_mask2,110,255,cv2.THRESH_BINARY)
    SET ret3,th3 TO cv2.threshold(img_mask3,110,255,cv2.THRESH_BINARY)
    # Applying an adaptive threshold to the image.
    SET tg1 TO cv2.adaptiveThreshold(th1,255,cv2.ADAPTIVE_THRESH_GAUSSIAN_C,\
            cv2.THRESH_BINARY,11,2)
    SET tg2 TO cv2.adaptiveThreshold(th2,255,cv2.ADAPTIVE_THRESH_GAUSSIAN_C,\
            cv2.THRESH_BINARY,11,2)
    SET tg3 TO cv2.adaptiveThreshold(th3,255,cv2.ADAPTIVE_THRESH_GAUSSIAN_C,\
            cv2.THRESH_BINARY,11,2)
    # Creating a grid of 4 rows and 3 columns.
    SET fig TO plt.figure(constrained_layout=True)
    SET gs TO GridSpec(4, 3, figure=fig)
    img=Image.open(file).convert('L') 
    SET axs TO fig.add_subplot(gs[0, :])
    axs.imshow(img,'gray')
    # Creating a list of images and then plotting them in a grid.
    SET images TO [img_mask,img_mask2,img_mask3,th1 ,th2,th3,tg1,tg2,tg3]
    FOR i IN range(9):
        SET ax TO fig.add_subplot(gs[i+3])
        ax.imshow(images[i],'gray',vmin=0,vmax=255)
    fig.align_labels()  # same as fig.align_xlabels(); fig.align_ylabels()
    plt.show()
DEFINE FUNCTION open_file_dialog():
    """
    It opens a file dialog and returns the path of the file selected.
    """
    SET file_path TO filedialog.askopenfilename()
    OUTPUT(file_path)
    file=str(file_path)
    procesado_principal(file)
# Creating a button that when clicked opens a file dialog.
SET root TO tk.Tk()
SET button TO tk.Button(root, text="Open File", command=open_file_dialog)
button.pack()
root.mainloop()